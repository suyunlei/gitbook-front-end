# 二叉树
## 满二叉树
如果一棵二叉树只有度为0的节点和度为2的节点，并且度为0的节点都在同一层上，则这棵二叉树为满二叉树。

## 完全二叉树
在完全二叉树中，除了最底层没被填满外，其余每层节点都达到最大值。并且最下面一层节点都集中在该层最左边的若干位置。
> 优先级队列其实是一个堆，堆就是一棵完全二叉树，同时保证父子节点的顺序关系

## 二叉搜索树
二叉搜索树是一个有序树。

- 若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；
- 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；
- 它的左、右子树也分别为二叉排序树

## 平衡二叉搜索树
它是一棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

## 二叉树的存储
- 链式存储
- 顺序存储
![顺序存储](./images/binery-tree.png)

如果父节点的数组下标是 `i`，那么它的左孩子就是 `i * 2 + 1`，右孩子就是 `i * 2 + 2`。

## 二叉树的遍历
- 深度优先遍历 dfs
    - 前序遍历 中左右
    - 中序遍历 左中右
    - 后序遍历 左右中
> 通常使用递归来实现。栈是一种递归实现的数据结构。所以也可以使用`栈`来迭代实现。
- 广度优先遍历 bfs
    - 层序遍历
> 通常使用`队列`来迭代实现。

---

# 堆
堆是一棵完全二叉树，堆中的某个节点的值总是不小于或者不大于其父节点的值。
堆相比普通数组和顺序数组，可以有效提高入队和出队效率。 O(logn).

---

# 排序
## 插入排序
插入排序的平均时间复杂度也是 O(n^2)，空间复杂度为常数阶 O(1).
插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较 N-1 次，时间复杂度为 O(N)。最坏的情况是待排序数组是逆序的，此时需要比较次数最多，最坏的情况是 O(n^2)。

思想： 从第二个元素开始，不断地和前面的元素进行比较。如果比他大，则进行下一个元素。如果比他小，则交换位置，直到比前一个元素大为止。

## 希尔排序
希尔排序时间复杂度是 O(n^(1.3-2))，空间复杂度为常数阶 O(1)

希尔排序目的为了加快速度改进了插入排序，交换不相邻的元素对数组的局部进行排序，并最终用插入排序将局部有序的数组排序。

在此我们选择增量 gap=length/2，缩小增量以 gap = gap/2 的方式

## 归并排序
是采用**分治法**的一个典型应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。

归并排序的时间复杂度为 O(nlogn)。归并排序时需要和待排序记录个数相等的存储空间，所以空间复杂度为 O(n)。

归并排序适用于数据量大，并且对稳定性有要求的场景。

## 快速排序
时间复杂度 O(nlogn) ， 空间复杂度  O(nlogn)。
``` javascript
var quickSort = function(arr) {
  if (arr.length <= 1) {
    return arr;
  }
  var pivotIndex = Math.floor(arr.length / 2);
  var pivot = arr.splice(pivotIndex, 1)[0]; // 重点 一定要splice出来
  var left = [];
  var right = [];

  for (var i = 0; i < arr.length; i++) {
    if (arr[i] < pivot) {
      left.push(arr[i]);
    } else {
      right.push(arr[i]);
    }
  }
  return quickSort(left).concat([pivot], quickSort(right));
};
```


